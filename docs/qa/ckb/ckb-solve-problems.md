---
id: ckb-solve-problems
title: CKB 解决了哪些问题
sidebar_label: CKB 解决了哪些问题
---

**状态爆炸**，**公地悲剧**

## 小白版

区块链作为一台世界计算机，其资源肯定是有限的，这种有限体现在 Bitcoin 和 Ethereum 7/15 tps，因此并非所有人都能够使用到该资源。当所有人都挤着脑袋需要使用这台电脑时，理所当然的，在区块链上的用户或者开发者需要使用和占用这些有限的资源进行付费。

在 Bitcoin、Ethereum 上，这些费用被笼统地以交易手续费的形式支付，你支付一次交易手续费，就可以使用一部分带宽、CPU、内容以及占用一部分硬盘空间。目前 Ethereum 已经意识到了仅仅采用交易费的方式来使用有限的区块链资源的缺陷：全节点状态爆炸，大量垃圾数据堆积等等。

EOS 与 Nervos 的设计则更进一步，对于这台世界计算机的各个部分进行了额外的设计。

EOS 拆分了计算机资源，并将内存资源（RAM）的地位提升，用户需要通过 EOS 购买 RAM，同时需要抵押 EOS 获得 CPU、带宽，EOS 似乎并不关心硬盘资源。

而 Nervos 将硬盘存储资源的地位拔升，1 CKB 占据世界状态 1 Byte 的使用空间，而对于 CPU、内存、带宽则笼统地以交易手续费的形式进行收费。

这样的设计有何意义，又究竟会给这条公链带来什么样的特性呢？我们可以从区块链设计的目的出发进行对比，结论非常有意思！

对于 EOS 来说，其关心的是区块链的商业化应用，因此低延迟（Low Latency）是 EOS 的设计要旨之一。

去中心化应用的低延迟需要交易的快速敲定，而交易的快速敲定则需要快速的网络、CPU 与内存资源（硬盘读取相比内存读取显然还是略慢了一点）。由于带宽与 CPU 是可循环使用的，两者采用了抵押的方式；而内存总量受限，则采用了用代币购买的方式。这意味着 RAM 是更加稀缺的资源。由于 EOS 独特的 DPos 共识算法，真正具备出块权仅为 21 个超级节点，廉价的硬盘资源显然是 EOS 生态最无需考虑的问题。

但是 EOS 真正的实现了这一目标吗？不知道你有没有了解最近在 EOS 上非常火热的项目 EIDOS。EIDOS 通过一种空投机制，将 EOS 资源设计机制的弊病暴露无遗，当 eos 网络的使用人数的上升，交易笔数增多进而发生拥堵时，这个时候用户为了进行一笔可能只有 0.001 eos 的转账，可能需要抵押成百上千的 eos 去获取 CPU 资源。并且如果你 eos 账户内的 CPU 耗尽，你将无法进行任何转账操作，不得不求助于朋友或者别的账户帮你抵押 eos 获取 CPU 资源，而这种情况在以太坊上并不会出现。

关键是，出现这样的问题违背了 EOS 设计的初衷么？其实并没有，EOS 依然是一个低延迟的网络，前提是你需要抵押足够多的 eos 去获取对应的瞬时资源，只要有钱你依然可以在 EOS 的网络上愉快的玩耍，当然这样一个需要抵押巨额 eos 去完成一笔可能非常小额的转账的残酷现实，让人不禁质疑整个设计的正确性。

而 Nervos 的设计偏重于能够长期稳定可靠运行的去中心化。

对于 Nervos 来说，公链真正需要关心的是去中心化，因此选择 PoW 作为共识算法，降低全节点门槛等等都是其设计的必然归宿。一个总量受限的世界状态意味着硬盘存储的总量是受限的，也因此能够确保全节点的硬盘总量受限，而使得普通用户都能够跑一个全节点。与此同时，PoW 区块链往往需要多个区块后才能够敲定交易，也因此没有办法实时（譬如 1s）地反馈用户操作，因此带宽、CPU、内存等能够帮助去中心化应用快速敲定交易的计算机资源就显得没有这么重要了（因为应用从开始到敲定的时间必然是比较长的 —— 与一般的互联网产品对比），这应该是 Layer2 考虑的问题。

是的！Nervos 和 EOS 的设计都是基于稀缺资源的供需调节机制，需求越高，意味着资源使用程度或者炒作程度越高，价格越高。不一样的是 EOS 是让你花费大量的资源用于抵押获取瞬时资源，而在 Nervos 上你获取的将是长久的可升值的存储资源。

### CKB 解决了状态爆炸

可以说任何一个不对状态总量进行限制的区块链，理论上都会面临状态爆炸的问题。

在这里我们首先得明确，这里提到状态指的是什么，CKB 锚定的状态空间究竟有多大，为什么要在设计初期就需要解决状态爆炸的问题？

区块链网络中每一个全节点，在运行过程中都会保存一些区块链的数据，这些数据主要包含几个部分：历史交易数据，历史状态和当前世界状态。历史交易数据，就是从区块链的第一个区块到当前区块高度，每个区块中发生的转账交易的数据。而一个地址内曾经有过哪些 Token，Token 的数量是多少，这些就属于历史状态，而当前世界状态，指的是目前区块链上所有的地址上现在有什么种类的 Token，有多少 Token，以及当前的区块链上有多少的智能合约和一些其他数据，当前世界状态描述的是从区块诞生到当前高度为止，所有交易形成后的最终结果。

拿微信钱包打比方的话，你使用微信钱包接收红包、进行支付这些都属于历史交易数据；你微信钱包在曾经的各个时间点上有多少钱，属于历史状态；而你微信钱包里目前现在有多少钱，就是当前状态。理论上你只要拥有了历史交易数据，你是可以计算出所有的历史状态和当前状态的，但是因为当前状态是需要实时查看的，因此不能删除，而历史状态其实是可以裁剪掉的。

而 CKB 锚定的就是上面所说的当前世界状态的存储空间。

那么 CKB 锚定的状态空间究竟会有多大？让我们来看一下 Bitcoin 和 Ethereum 的数据。因为 Bitcoin 采用的是 UTXO 模型，因此历史交易数据和历史状态是一致的，这里我们就不细分解释了，目前 Bitcoin 整个数据的大小（所有区块加起来的大小）大约是 200G（既是历史交易数据，也是历史状态数据） ，而当前世界状态的大小只有 ~ 3G（由 ~ 5000 万个 UTXO 组成）。而对于 Ethereum，所有数据加起来的大小超过了 2 TB，其中历史交易数据大概是 190G，当前世界状态大概是 20G，剩下的都是历史状态。

正如我们看到的实际上对于 Bitcoin 和 Ethereum 上的全节点目前不可删减的数据（就是历史交易数据 + 当前世界状态数据）目前其实差不多都是二百多 G，产生这么多数据，比特币用了十年，而以太坊只用了四年。

而这是在我们还没有解决可扩展性问题，区块链仍然是小众技术的情况下的增长速度。当我们解决了可扩展性问题，区块链真正获得大范围应用，DApp 和用户数量都呈现几何爆炸式增长的时候，区块链历史交易数据和当前世界状态数据会以什么速度累积呢？

对于历史交易数据，我们未来是可以通过中心化地加入检查点或者是采用零知识证明技术等方式来进行删减或压缩，但是，当前世界状态是始终无法删减的，拿上面微信钱包的例子，腾讯可以把历史状态和历史交易数据都删掉了，但是腾讯不能把你当前微信钱包内有多少钱的数据给删除掉。

区块链，特别是公链，特别是目标成为共同知识库的公链，必须在设计之初就要解决状态爆炸的问题。

而 1 CKB 锚定的就是 1 Byte 的当前世界状态。因此 CKB 发行数量的限制是可以真正地限制当前世界状态大小的，也是可以真正解决状态爆炸问题的。


### CKB 化解了公地悲剧

为了更好地理解公地悲剧这个问题，我们这里通过一个故事去讲解一下。

Bitcoin 就好比在一个村庄的中心放置了一个计算器，村民之间相互转账的时候都需要到这个计算器上进行一下计算，这样算出来的数据才是准确的有效的，当然村民每次使用的时候都需要支付一丢丢的手续费。

而 Ethereum 是图灵完备的，可以部署智能合约，在计算器的基础上，升级成了一台可以使用的电脑，虽然这台电脑性能一般，但相比于计算器还是有了很大的提升，可以实现更加丰富的功能。村民们除了可以进行 ETH 转账，还可以在这一台电脑上创建别的 Token 进行转账交易，比如各类的 ERC20 和 ERC721，村民还可以在上面存入各类的智能合约和其他数据。而村民每次使用这台电脑，也只需要支付一丢丢手续费即可。对于这样一台公用的电脑而言，带宽、CPU、内存这些瞬时资源都是可以即时恢复的，但是硬盘却不是，村民存入的数据永久的保存在了电脑里面，这个时候一些村民写入的没有用的或者过时的数据依然保留在硬盘中，因为村民并不需要为这部分占用付出额外的代价，因此写入数据的村民并没有将这一部分数据删除的动力，长此以往就变成了公地悲剧，有限的共享资源在不受任何限制的情况下被人们过度消耗。

CKB 则不同，CKB 作为一台更加优异的电脑出现在村中心时，村民使用这台电脑同样需要支付一部分手续费，而当村民需要在这台电脑上保存数据的时候，村民还需要购买 CKB，从而才能换取一部分在这台电脑上保存数据的空间。不持有 CKB 的村民，是没有办法在 Nervos CKB 网络上存储数据的，没有办法持有这个网络上创造的其他 Token，没有办法创建智能合约，没有办法存入数据。

而随着 CKB 价值的提升，当其他所有的村民平均用 1000 CKB 存储空间去存储价值约为 1000 元的数据或者 Token 时，而你在用 1000 CKB 存储空间去存储价值约为 100 元的数据或者 Token，这个时候，你和大家都付出了同样的存储成本和风险，但是显然你的存储空间的价值密度要比别人要低。这个时候你会不会选择出让一部分 CKB 存储空间给他人或者选择存入更高价值的数据或者 Token 呢？

## 进阶版

### The Tragedy of (Storage) Commons：区块链版本的公地悲剧


[公地悲剧](https://en.wikipedia.org/wiki/Tragedy_of_the_commons)所指的是这样一种情况，有限的共享资源在不受任何限制的使用下被人们过度消耗。区块链节点为保存历史和状态付出的存储，正是这样一种共享资源。

区块链节点为处理交易所花费的资源有三种，CPU，存储和网络带宽。CPU 和带宽都是每个区块会刷新的资源，我们可以认为每个区块间隔内都用同样多的 CPU和带宽可供使用，上个区块消耗掉的CPU和带宽不会让下个区块可用的 CPU 和带宽变少。对于可刷新的资源，我们可以通过一次性支付的交易手续费来补偿节点（手续费与计算复杂度和交易大小的相关性可参考 [RFC0015 Appendix](https://github.com/nervosnetwork/rfcs/blob/0015-crypto/rfcs/0015-ckb-cryptoeconomics/0015-ckb-cryptoeconomics.md)）。

与 CPU 和带宽不同，存储是一种占用资源，在一个区块中被占用了的存储，除非使用者主动释放，否则无法在后面的区块中被其它使用者使用。节点需要为存储持续的付出成本，而使用者却不需要为存储持续的支付手续费（记住交易手续费只需要支付一次）。使用者只需要在往区块链写数据的时候支付一点点手续费，就可以永久使用一个可用性超过 Amazon S3 的存储，其无限大的永久存储成本需要区块链网络中的所有全节点来承担。

Ethereum 上由于各种 DApp 的存在，The Tragedy of (Storage) Commons 相对更加严重。例如，[在区块5700001（May 30, 2018）的时候，使用状态最多的5个合约](https://github.com/Mine77/eth-storage-analyze/blob/master/data/first200_on5700001.csv) 是：

1. EtherDelta, 5.09%
2. IDEX, 4.17%
3. CryptoKitties, 3.05%
4. ENS, 1.92%
5. EOS Sale, 1.73%

比较有趣的是最后一个，EOS Sale。虽然 EOS 的众筹已经完成，EOS 代币已经在 EOS 链上流转，EOS 众筹的记录却永远留在了 Ethereum 的节点上，消耗 Ethereum 全节点的存储资源。

可以看到，在缺乏管理的情况下，区块链的存储资源会被有意或者无意的滥用。在一个设计合理的经济模型中，使用者必须承担存储占用的成本，这个成本不仅仅与占用存储空间的大小成正比，还与占用时间的长度成正比。

### 状态爆炸

无论是历史还是状态数据都会占用存储资源。通过上面对 Bitcoin 和 Ethereum 的分析（其他区块链的状态模型基本都可以归纳为二者之一）可以看到，虽然它们对历史和状态的增长进行了管理，但是对历史和状态的总大小却没有任何控制，这些数据会持续的无休止的累积下去，使得运行全节点需要的存储资源越来越大，[提高全节点的运行门槛，使网络的去中心化程度越来越低](https://talk.nervos.org/t/dont-trust-verify/335)，这是我们不愿意看到的。

你也许会说，有没有可能硬件平均水平的提高会超过历史和状态的积累速度？我的回答是可能性很低：

![storage_growth](images/eth-storage-growth.png)

从这张图中我们可以看到，随着 Ethereum 网络的发展，状态数据累积的数量呈指数式的增长。Bitcoin 的状态数据从 0 积累到 3 G，用了 10 年；Ethereum 的状态数据从 0 积累到 10 G，用了 4 年；而这是在我们还没有解决 Scalability 问题，区块链仍然是小众技术的情况下的增长速度。当我们解决了 scalability 问题，区块链真正获得 mass adoption，DApp 和用户数量都爆炸式增长的时候，区块链历史和状态数据会以什么速度累积呢？

这就是状态爆炸问题，我们把它归类为 post-scalability problem，因为它在解决 scalability 问题之后会非常明显。我们最早是在做[许可链场景落地](https://www.citahub.com/) 时注意到了这个问题，因为[许可链的性能远高于公有链](https://mp.weixin.qq.com/s/nKcM4G9plxZLneFtea6Lpg)，刚好处于 post-scalability 的阶段。

历史数据的累积相对容易处理，未来可以通过去中心化的 Checkpoint 或是零知识证明等技术来压缩，在那之前全节点甚至可以把历史直接丢掉，依然可以正常运行。 状态数据的累积则麻烦许多，因为它是全节点运行必须的数据。

不少区块链项目已经看到了这个问题，并提出了一些解决方案。EOS RAM 是解决状态爆炸问题的一个有益尝试：RAM 代表了超级节点服务器可用的内存资源，无论是账户、合约状态还是代码，都需要占用一定的 RAM 才能运行。RAM 的设计也有很多问题，它需要通过内置的交易市场购买，不可转让，无法租用，将合约执行过程中的短期内存需求和合约状态的长期存储需求混在了一起，而且 RAM 的总量的设定没有确定的规则，更多取决于超级节点可以承受的硬件配置，而非[共识空间的成本](https://talk.nervos.org/t/nervos-bitcoin/1372/50?u=janx)。

Ethereum社区也看到了这个问题并提出了 [Storage Rent 的方案](https://github.com/ethereum/EIPs/pull/1682)：要求使用者为存储资源的使用预支付一笔租金，占用存储资源会持续消耗这笔租金，占用时间越长，使用者需要支付的租金越多。Storage Rent 方案存在两个问题：

1. 预支付的租金终有一天会用完，这时候如何处理占用的状态？正是为解决这个问题，Storage Rent 需要诸如 resurrection 的机制来补充，[增加了设计的复杂度](https://github.com/ledgerwatch/eth_state/blob/master/State_Fees_3.pdf)，使智能合约的 immutability 大打折扣，也为[使用体验带来了麻烦](https://ethresear.ch/t/improving-ux-for-storage-rent/3994)；

2. Ethereum 的状态模型是一种共享状态的模型，[而不是First-class State](https://talk.nervos.org/t/first-class-asset/405)。以 ERC20 Token 为例，所有用户的资产记录都存放在单个 ERC20 合约的存储里面，在这种情况下，应该由谁来支付租金？

解决状态爆炸问题也是 Nervos CKB 的设计目标之一，为此 CKB 走了一条完全不同的、更为彻底的变革之路。